---
title: "Test Odds Ratios"
---

```{r}
#| label: setup
#| include: false
library(here)
source(here("utils","check_packages.R"))
source(here("utils","functions.R"))
```

The purpose of this document is to examine how the results from the conditional logit models compare to more traditional log-linear results or even simple cross-products from a contingency table of marriages. We know they differ for two important reasons:

* Specification of a tighter marriage market from which to draw alternatives
* Inclusion of non-married population as potential alternatives

These are both clear advantages of the conditional logit approach. However, what if we were just to naively use only existing partners as alternatives and sample alternates from a single pool, and we fit a model only with the racial exogamy terms? Intuitively, we would expect this to resemble the cross-products from a contingency model.

To test this out I am going to use fake simulated data with only two groups. For simplicity, I assume gender symmetry such that I get a table like:

|                 | Group A Wife | Group B Wife |
|-----------------|--------------|--------------|
| Group A Husband | x            |       y      | 
| Group B Husband | y            |       z      |

Where $A$ and $B$ are the size of groups A and B size, respectively. Thus, $A=x+2y$ and $B=z+2y$. I also assume that group A's size is some multiple $D$ of group B such that $A=DB$.

Technically, I want the to take reverse cross-products rather than cross-products because I want the odds of exogamy not endogamy. So:

$$\frac{y^2}{xz}=O$$

Where $O$ is the odds ratio of exogamy. This means:

$$y^2=Oxz$$

and I also know that:

$$z=B-2y$$

$$x=DB-2y$$

So, 

$$y^2=O(DB-2y)(B-2y)$$


$$y^2=O(4y^2+(-2D-2)By+DB^2)$$

$$0=(4-\frac{1}{O})y^2+(-2D-2)By+DB^2$$

This allows me to quadratic things up to get:

$$y=\frac{(2D+2)B-\sqrt{((-2D-2)B)^2-4*(4-\frac{1}{O})DB^2}}{8-\frac{2}{O}}$$

$$y=\frac{(2D+2)B-B\sqrt{4D^2+8D+4-16D+\frac{4D}{O}}}{8-\frac{2}{O}}$$
$$y=\frac{(2D+2)B-B\sqrt{4D^2-8D+4+\frac{4D}{O}}}{8-\frac{2}{O}}$$
This means that I should be able to specify tables entirely in terms of $B$, $D$, and $O$ and use these to calculate $x$, $y$, and $z$, although I will have to round to whole numbers.

```{r}
solve_y <- function(B,D,O) {
  ((2*D+2)*B-B*sqrt(4*D^2-8*D+4+4*D/O))/(8-2/O)
}

```


## Creating functions

To run the models, I create a function that will take the values of $x$, $y$, and $z$ and use them to create a counterfactual union dataset, run the model, and extract the exogamy coefficient. 

```{r}
#| label: create-functions
calculate_model_coef <- function(x, y, z, nalts=25) {
  
  maraa <- data.frame(idh=1:x, idw=1:x, raceh="A", racew="A", 
                      market="A")
  marbb <- data.frame(idh=(x+1):(x+z), 
                      idw=(x+1):(x+z), 
                      raceh="B", racew="B", market="A")
  marba <- data.frame(idh=(x+z+1):(x+z+y), 
                      idw=(x+z+1):(x+z+y), 
                      raceh="B", racew="A", market="A")
  marab <- data.frame(idh=(x+z+y+1):(x+z+2*y), 
                      idw=(x+z+y+1):(x+z+2*y), 
                      raceh="A", racew="B", market="A")
  
  marriages <- bind_rows(maraa, marbb, marba, marab) |>
    mutate(raceh=factor(raceh, levels=c("A","B")),
           racew=factor(racew, levels=c("A","B")))
  
  men <- marriages |>
    select(idh, raceh, market)
  women <- marriages |>
    select(idw, racew, market)
  
  market <- generateCouples(nalts, marriages, men, women, "market",
                            verbose = FALSE)
  
  market$rexog <- createExogamyTerms(market$raceh, market$racew, 
                                     symmetric=TRUE)
  
  model <- clogit(choice~raceh+racew+rexog+strata(group), data=market)
  
  return(coef=coef(model)[3])
}


create_scenarios <- function(B, D, O) {
  tibble(y=floor(solve_y(B,D,O)), x=D*B-2*y, z=B-2*y, 
         lor=2*log(y)-log(x)-log(z))
}
```

By default, I use 25 alternates. I will test whether this issue has any effect below.

I will set a group of default odds ratios for each scenario I test based on log-odds:

```{r}
#| label: set-odds-ratios
lor <- c(-12, -9, -8, -6, -5, -4, -3, -2, -1, -0.5, 0)
default_or <- exp(lor)
```

## Even group size

I start with a case where population sizes are even

````{r}
#| label: tbl-scenario-even
#| tbl-cap: Scenarios with very even group sizes (1:1)
scenarios_even <- create_scenarios(10000, 1, default_or) |>
  rowwise() |>
  mutate(coef=calculate_model_coef(x, y, z))

scenarios_even |>
  gt() |>
  cols_label(lor="cross-product log odds ratio", 
             coef="conditional logit model coefficient") |>
  fmt_number(columns=c(lor, coef), decimals=3)
```

Let's compare the model coefficients from the conditional logit model to the log odds ratios from the contingency table.

```{r}
#| label: fig-even-scenario
#| fig-cap: Relationship between cross-product log odds ratio predicting exogamy and counterfactual union conditional logit model coefficient based on simulated data with two groups of equal size. Blue line shows linear fit with a forced y-intercept of zero.
scenarios_even |>
  ggplot(aes(lor, coef))+
  geom_smooth(method="lm",  se=FALSE, formula=y~-1+x)+
  geom_point()+
  geom_hline(yintercept = 0, linetype=2)+
  geom_vline(xintercept = 0, linetype=2)+
  labs(x="log odds ratio from cross product", 
       y="conditional logit coefficient")+
  theme_bw()
```

The result is a perfect linear fit in which the conditional logit coefficients are half the value of the log odds ratio. I confirm this with a linear model:

```{r}
#| label: model-even

summary(lm(coef~-1+lor, data=scenarios_even))
```

I suspect the reason that this does not fit 0.5 exactly is the slightly stochastic nature of the conditional logit approach.

## Very uneven group size

I now take a case with very uneven group sizes of 40:1 to see how this affects the results.

````{r}
#| label: tbl-scenario-very-uneven
#| tbl-cap: Scenarios with very uneven group sizes (40:1)
scenarios_very_uneven <- create_scenarios(500, 40, default_or) |>
  rowwise() |>
  mutate(coef=calculate_model_coef(x, y, z))

scenarios_very_uneven |>
  gt() |>
  cols_label(lor="cross-product log odds ratio", 
             coef="conditional logit model coefficient") |>
  fmt_number(columns=c(lor, coef), decimals=3)
```


```{r}
#| label: fig-uneven-scenario
#| fig-cap: Relationship between cross-product log odds ratio predicting exogamy and counterfactual union conditional logit model coefficient based on simulated data with two groups of unequal size (40:1). Blue line shows linear fit with a forced y-intercept of zero.

scenarios_very_uneven |>
  ggplot(aes(lor, coef))+
  geom_smooth(method="lm",  se=FALSE, formula=y~-1+x)+
  geom_smooth(se=FALSE, color="red")+
  geom_point()+
  geom_hline(yintercept = 0, linetype=2)+
  geom_vline(xintercept = 0, linetype=2)+
  labs(x="log odds ratio from cross product", 
       y="conditional logit coefficient")+
  theme_bw()
```

~~The results here are clearly nonlinear. At some point we get a crossover so that the conditional logit model leads to much smaller log-odds than the cross-product at low log odds (> -6), and larger log-odds than the cross-product at high log odds (< -7).

To explore how severe this difference is, I want to test this at multiple values of $D$ whilst holding everything else the same.~~

**UPDATE: adding in a control for the race of the alternate partner fixed this problem as the updated figure shows.**

$$20000=B(1+D)$$

$$\frac{20000}{1+D}$$

```{r}
#| label: scenarios-full
scenarios_even <- scenarios_even |>
  mutate(D=1)

scenarios_very_uneven <- scenarios_very_uneven |>
  mutate(D=40)

scenarios <- bind_rows(scenarios_even, scenarios_very_uneven)

D <- c(10, 5, 2)
for(d in D) {
  scenarios <- create_scenarios(floor(20000/(1+d)), d, default_or) |>
    rowwise() |>
    mutate(coef=calculate_model_coef(x, y, z), D=d) |>
    bind_rows(scenarios)
}

```


```{r}
scenarios |>
  ggplot(aes(lor, coef, color=factor(D)))+
  geom_smooth(se=FALSE)+
  geom_point()+
  geom_hline(yintercept = 0, linetype=2)+
  geom_vline(xintercept = 0, linetype=2)+
  scale_color_viridis_d()+
  labs(x="log odds ratio from cross product", 
       y="conditional logit coefficient",
       color="Group size ratio")+
  theme_bw()
```

~~The differences are pretty minor for the 2:1 and 5:1 group size ratio. Even for the 10:1 case its reasonably good. By 40:1 the skew is pretty important though.~~

**UPDATE: As noted above, adding in a control for the race of the alternate partner fixed this problem as the figure shows.**

## Changes depending on other groups

First lets load the markets data and make a function to create a model using a subset of groups.

```{r}
#| label: load-markets
load(here("data","data_constructed","markets.RData"))

# built model from actual marriages
# * restrict to 2018-19 so models run faster
actual <- mar_markets[[1]] |>
  mutate(year=as.numeric(str_sub(idh, -2, -1))) |>
  filter(choice & year>17)
```

```{r}
#| label: function-gen-subset

run_subset <- function(groups, nfakes=20) {
  
  marriages <- actual |>
    mutate(mar_market=1) |>
    filter((raceh %in% groups & racew %in% groups) & year>17) |>
    mutate(raceh=droplevels(raceh), racew=droplevels(racew)) |>
    select(idh, idw, raceh, racew, mar_market)
  
  men <- marriages |>
    select(idh, raceh, mar_market)
  women <- marriages |>
    select(idw, racew, mar_market)
  
  market<- generateCouples(nfakes, as.data.frame(marriages), 
                           as.data.frame(men), as.data.frame(women), 
                           "mar_market", verbose = FALSE)
  
  market$rexog <- createExogamyTerms(market$raceh, market$racew, 
                                     symmetric=TRUE)
  
  market <- market |>
    filter(!choice) |>
    filter(!duplicated(group)) |>
    mutate(whose=ifelse(group==idh, "husband", "wife")) |>
    select(group, whose) |>
    right_join(market)

  
  market$race_alt <- ifelse(market$whose=="wife", as.character(market$raceh), 
                            as.character(market$racew))
  
  model <- clogit(choice~race_alt+rexog+strata(group), data=market, method="efron")

  return(model)
}
```

```{r}
#| label: mono-compare

# how does this affect monoracial groups
mono_groups <- c("White","Black","Asian","Latino, Single Race", "Indigenous")
model_mono <- run_subset(mono_groups)

model_wb <- run_subset(c("White","Black"))
model_wa <- run_subset(c("White","Asian"))
model_wl <- run_subset(c("White","Latino, Single Race"))
model_wi <- run_subset(c("White","Indigenous"))
model_ba <- run_subset(c("Black","Asian"))
model_bl <- run_subset(c("Black","Latino, Single Race"))
model_bi <- run_subset(c("Black","Indigenous"))
model_al <- run_subset(c("Asian","Latino, Single Race"))
model_ai <- run_subset(c("Asian","Indigenous"))
model_li <- run_subset(c("Latino, Single Race","Indigenous"))

coef_bi <- sapply(list(model_wb, model_wi, model_wa, model_wl, model_bi, 
                       model_ba, model_bl, model_ai, model_li, model_al), 
                  function(x) {coef(x)[2]}) |>
  enframe(name = "rexog", value="coef_bi") |>
  mutate(rexog=str_replace(rexog, "rexog", ""))

coef_compare <- coef(model_mono) |>
  enframe(name="rexog", value="coef_full") |>
  filter(str_detect(rexog, "rexog")) |>
  mutate(rexog=str_replace(rexog, "rexog", "")) |>
  full_join(coef_bi)

ggplot(coef_compare, aes(x=coef_full, y=coef_bi))+
  geom_abline(yintercept=0, slope=1, linetype=2)+
  geom_point()+
  geom_text_repel(aes(label=rexog))+
  theme_bw()

tab <- table(actual$raceh, actual$racew)[mono_groups, mono_groups]

lor <- tibble()
gr <- c("White","Black","Indigenous","Asian","Latino, Single Race")
for(i in 1:(length(gr)-1)) {
  group1 <- gr[i]
  for(j in (i+1):length(gr)) {
    group2 <- gr[j]
    cp <- tab[c(group1, group2), c(group1, group2)]
    x <- tibble(rexog=paste(group1, group2, sep="."),
                lor=log(cp[1,2])+log(cp[2,1])-log(cp[1,1])-log(cp[2,2]))
    lor <- bind_rows(lor, x)
  }
}

coef_compare |>
  right_join(lor) |>
  ggplot(aes(x=lor, y=coef_full))+
  geom_smooth(method="lm", se=FALSE, formula=y~-1+x)+
  geom_point()+
  theme_bw()
```
~~Results are solid except for three of the four cases involving indigenous populations. The one that is fine is White/Indigenous. This suggests that the results are biased for small groups (in this case Indigenous) when including a very large group (in this case Whites) except for the comparison that directly involves the large group.~~ 

**Update: these problems were fixed by controlling for the race of the alternate partner**